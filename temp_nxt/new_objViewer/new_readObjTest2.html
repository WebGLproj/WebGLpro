<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>测试读取obj2</title>
</head>
<body onload="main()">
<canvas id="webgl" width="1600" height="1000">
    Please use a browser that supports "canvas"
</canvas>

<script src="../lib/webgl-utils.js"></script>
<script src="../lib/webgl-debug.js"></script>
<script src="../lib/cuon-utils.js"></script>
<script src="../lib/cuon-matrix.js"></script>
<script src="new_readObj.js"></script>

<script>
    var modelObject = [];
    var mtlArray = [];
    var objArray = [];
    var g_modelMatrix = new Matrix4();
    var g_mvpMatrix = new Matrix4();
    var g_normalMatrix = new Matrix4();

    //需要绑定this 这里面的this就是对于每一个模型来说总的内容的实例
   function getDrawingInfo() {
       console.log(this,"this");
        // Create an arrays for vertex coordinates, normals, colors, and indices
        var numIndices = 0;
        for(var i = 0; i < this.objects.length; i++){
            numIndices += this.objects[i].numIndices;
            //每一个objects[i].numIndices 是它的所有的face的顶点数加起来
        }
        var numVertices = numIndices;
        var vertices = new Float32Array(numVertices * 3);
        var normals = new Float32Array(numVertices * 3);
        var colors = new Float32Array(numVertices * 4);
        var indices = new Uint16Array(numIndices);

        // Set vertex, normal and color
        //一个face一个face的遍历
        var index_indices = 0;
        for(i = 0; i < this.objects.length; i++){
            var object = this.objects[i];
            for(var j = 0; j < object.faces.length; j++){
                var face = object.faces[j];
                var color = findColor(this,face.materialName);
                // console.log(face.materialName,color);
                var faceNormal = face.normal;
                for(var k = 0; k < face.vIndices.length; k++){
                    // Set index
                    indices[index_indices] = index_indices;
                    // Copy vertex
                    var vIdx = face.vIndices[k];
                    var vertex = this.vertices[vIdx];
                    vertices[index_indices * 3    ] = vertex.x;
                    vertices[index_indices * 3 + 1] = vertex.y;
                    vertices[index_indices * 3 + 2] = vertex.z;
                    // Copy color
                    colors[index_indices * 4    ] = color.r;
                    colors[index_indices * 4 + 1] = color.g;
                    colors[index_indices * 4 + 2] = color.b;
                    colors[index_indices * 4 + 3] = color.a;
                    // console.log(colors,color);
                    // Copy normal
                    var nIdx = face.nIndices[k];
                    if(nIdx >= 0){
                        var normal = this.normals[nIdx];
                        normals[index_indices * 3    ] = normal.x;
                        normals[index_indices * 3 + 1] = normal.y;
                        normals[index_indices * 3 + 2] = normal.z;
                    }else{
                        normals[index_indices * 3    ] = faceNormal.x;
                        normals[index_indices * 3 + 1] = faceNormal.y;
                        normals[index_indices * 3 + 2] = faceNormal.z;
                    }
                    index_indices ++;
                }
            }
        }
        return new DrawingInfo(vertices, normals, colors, indices);
    }

    var ready = true;
    function onReadComplete(gl, model, target) {
        // Acquire the vertex coordinates and colors from OBJ file
        console.log("target",target);
        var drawingInfo = getDrawingInfo.apply(target);
        if(ready) {
            console.log(drawingInfo, "drawingInfo");
            ready = !ready;
        }
            // Write date into the buffer object
        gl.bindBuffer(gl.ARRAY_BUFFER, model.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.vertices, gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.normals, gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, model.colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.colors, gl.STATIC_DRAW);

        // Write the indices to the buffer object
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, drawingInfo.indices, gl.STATIC_DRAW);

        return drawingInfo;
    }


    var VSHADER_SOURCE =
            'attribute vec4 a_Position;\n' +
            'attribute vec4 a_Color;\n' +
            'attribute vec4 a_Normal;\n' +
            'uniform mat4 u_MvpMatrix;\n' +
            'uniform mat4 u_NormalMatrix;\n' +
            'varying vec4 v_Color;\n' +
            'void main() {\n' +
            '  vec3 lightDirection = vec3(-0.35, 0.35, 0.87);\n' +
            '  vec3 lightColor = vec3(0.45, 0.45, 0.45);\n' +
            '  gl_Position = u_MvpMatrix * a_Position;\n' +
            '  vec3 normal = normalize(vec3(u_NormalMatrix * a_Normal));\n' +
            '  float nDotL = max(dot(normal, lightDirection), 0.0);\n' +
            '  // v_Color = a_Color;\n' +
            '  v_Color = vec4(a_Color.rgb * nDotL + lightColor * a_Color.rgb , a_Color.a);\n' +
            '}\n';

    // Fragment shader program
    var FSHADER_SOURCE =
            '#ifdef GL_ES\n' +
            'precision mediump float;\n' +
            '#endif\n' +
            'varying vec4 v_Color;\n' +
            'void main() {\n' +
            '  gl_FragColor = v_Color;\n' +
            '}\n';

    function main() {
        // Retrieve <canvas> element
        var canvas = document.getElementById('webgl');

        // Get the rendering context for WebGL
        var gl = getWebGLContext(canvas);
        if (!gl) {
            console.log('Failed to get the rendering context for WebGL');
            return;
        }

        // Initialize shaders
        if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
            console.log('Failed to intialize shaders.');
            return;
        }

        // Set the clear color and enable the depth test
        gl.clearColor(0.2, 0.2, 0.2, 1.0);
        gl.enable(gl.DEPTH_TEST);

        // Get the storage locations of attribute and uniform variables
        var program = gl.program;
        program.a_Position = gl.getAttribLocation(program, 'a_Position');
        program.a_Normal = gl.getAttribLocation(program, 'a_Normal');
        program.a_Color = gl.getAttribLocation(program, 'a_Color');
        program.u_MvpMatrix = gl.getUniformLocation(program, 'u_MvpMatrix');
        program.u_NormalMatrix = gl.getUniformLocation(program, 'u_NormalMatrix');

        if (program.a_Position < 0 ||  program.a_Normal < 0 || program.a_Color < 0 ||
                !program.u_MvpMatrix || !program.u_NormalMatrix) {
            console.log('attribute, uniform失敗');
            return;
        }

        // Prepare empty buffer objects for vertex coordinates, colors, and normals
        var model = initVertexBuffers(gl, program);
        if (!model) {
            console.log('Failed to set the vertex information');
            return;
        }

        // ビュー投影行列を計算
        var viewProjMatrix = new Matrix4();
        viewProjMatrix.setPerspective(30.0, canvas.width/canvas.height, 1.0, 5000.0);
        viewProjMatrix.lookAt(0.0, 500.0, 200.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

        // Start reading the OBJ file
        readOBJFile('../resources/ChairSwing.obj', modelObject,  mtlArray, objArray, 100, false, 1);
        readOBJFile('./cube.obj', modelObject,  mtlArray, objArray, 20, false, 0);

        var currentAngle = [0.0, 0.0]; // Current rotation angle ([x-axis, y-axis] degrees)
        initEventHandlers(canvas, currentAngle);

        var tick = function() {   // Start drawing
            // currentAngle = animate(currentAngle); // Update current rotation angle
            draw(gl, gl.program, currentAngle, viewProjMatrix, model);
            requestAnimationFrame(tick, canvas);
        };
        tick();
    }


    function initEventHandlers(canvas, currentAngle) {
        var dragging = false;         // Dragging or not
        var lastX = -1, lastY = -1;   // Last position of the mouse

        canvas.onmousedown = function(ev) {   // Mouse is pressed
            var x = ev.clientX, y = ev.clientY;
            // Start dragging if a moue is in <canvas>
            var rect = ev.target.getBoundingClientRect();
            if (rect.left <= x && x < rect.right && rect.top <= y && y < rect.bottom) {
                lastX = x; lastY = y;
                dragging = true;
            }
        };

        canvas.onmouseup = function(ev) { dragging = false;  }; // Mouse is released

        canvas.onmousemove = function(ev) { // Mouse is moved
            var x = ev.clientX, y = ev.clientY;
            if (dragging) {
                var factor = 100/canvas.height; // The rotation ratio
                var dx = factor * (x - lastX);
                var dy = factor * (y - lastY);
                // Limit x-axis rotation angle to -90 to 90 degrees
                currentAngle[0] = Math.max(Math.min(currentAngle[0] + dy, 90.0), -90.0);
                currentAngle[1] = currentAngle[1] + dx;
            }
            lastX = x, lastY = y;
        };
    }



    // Create an buffer object and perform an initial configuration
    function initVertexBuffers(gl, program) {
        var o = new Object(); // Utilize Object object to return multiple buffer objects
        o.vertexBuffer = createEmptyArrayBuffer(gl, program.a_Position, 3, gl.FLOAT);
        o.normalBuffer = createEmptyArrayBuffer(gl, program.a_Normal, 3, gl.FLOAT);
        o.colorBuffer = createEmptyArrayBuffer(gl, program.a_Color, 4, gl.FLOAT);
        o.indexBuffer = gl.createBuffer();
        if (!o.vertexBuffer || !o.normalBuffer || !o.colorBuffer || !o.indexBuffer) { return null; }

        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        return o;
    }

    // Create a buffer object, assign it to attribute variables, and enable the assignment
    function createEmptyArrayBuffer(gl, a_attribute, num, type) {
        var buffer =  gl.createBuffer();  // Create a buffer object
        if (!buffer) {
            console.log('Failed to create the buffer object');
            return null;
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(a_attribute, num, type, true, 0, 0);  // Assign the buffer object to the attribute variable
        gl.enableVertexAttribArray(a_attribute);  // Enable the assignment

        return buffer;
    }

    // 描画関数
    function draw(gl, program, angle, viewProjMatrix, model) {

        if(mtlArray.length != 2 || objArray.length != 2 || mtlArray.some(function(x){return !x;}) || objArray.some(function(x){return !x;}  )){
            //这里代表的是对于所有模型而言，有模型没有被渲染好，那么就不能执行绘制操作
            console.log("nodraw",mtlArray,objArray,(mtlArray.some(function(x){return !x;}) || objArray.some(function(x){return !x;} || mtlArray.length == 0 || objArray.length == 0)));
            return;
        }
        //console.log("draw",mtlArray,objArray,mtlArray.length == 0,objArray.length == 0,(mtlArray.some(function(x){return !x;}) || objArray.some(function(x){return !x;} || mtlArray.length == 0 || objArray.length == 0)));

        console.log("modelObject1",modelObject[1],modelObject);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);  // Clear color and depth buffers

        g_drawingInfo = onReadComplete(gl, model, modelObject[0]);
        g_objDoc = null;


        g_modelMatrix.setRotate(angle[0], 1.0, 0.0, 0.0); // 设置模型旋转矩阵
        g_modelMatrix.rotate(angle[0], 0.0, 1.0, 0.0);
        g_modelMatrix.rotate(angle[1], 0.0, 0.0, 1.0);
        g_mvpMatrix.set(viewProjMatrix);

        // Calculate the normal transformation matrix and pass it to u_NormalMatrix
        g_normalMatrix.setInverseOf(g_modelMatrix);
        g_normalMatrix.transpose();
        gl.uniformMatrix4fv(program.u_NormalMatrix, false, g_normalMatrix.elements);

        // Calculate the model view project matrix and pass it to u_MvpMatrix
        // g_mvpMatrix.multiply(g_modelMatrix);
        g_mvpMatrix.rotate(angle[1], 0.0, 1.0, 0.0);
        g_mvpMatrix.rotate(angle[0], 1.0, 0.0, 0.0);
        gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements);

        // Draw
        gl.drawElements(gl.TRIANGLES, g_drawingInfo.indices.length, gl.UNSIGNED_SHORT, 0);

        //-----------------------------------------------------------------------------------------------


        g_drawingInfo = onReadComplete(gl, model, modelObject[1]);
        g_objDoc = null;

//        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);  // Clear color and depth buffers

        g_modelMatrix.setRotate(angle[0], 1.0, 0.0, 0.0); // 设置模型旋转矩阵
        g_modelMatrix.rotate(angle[0], 0.0, 1.0, 0.0);
        g_modelMatrix.rotate(angle[1], 0.0, 0.0, 1.0);
        g_mvpMatrix.set(viewProjMatrix);

        // Calculate the normal transformation matrix and pass it to u_NormalMatrix
        g_normalMatrix.setInverseOf(g_modelMatrix);
        g_normalMatrix.transpose();
        gl.uniformMatrix4fv(program.u_NormalMatrix, false, g_normalMatrix.elements);

        // Calculate the model view project matrix and pass it to u_MvpMatrix
        // g_mvpMatrix.multiply(g_modelMatrix);
        g_mvpMatrix.rotate(angle[1], 0.0, 1.0, 0.0);
        g_mvpMatrix.rotate(angle[0], 1.0, 0.0, 0.0);
        gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements);

        // Draw
        gl.drawElements(gl.TRIANGLES, g_drawingInfo.indices.length, gl.UNSIGNED_SHORT, 0);

    }

</script>
</body>
</html>