<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>webgl</title>
	<!-- 新 Bootstrap 核心 CSS 文件 -->
<link rel="stylesheet" href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css">

<!-- 可选的Bootstrap主题文件（一般不用引入） -->
<link rel="stylesheet" href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap-theme.min.css">

<!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->
<script src="http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>

<!-- 最新的 Bootstrap 核心 JavaScript 文件 -->
<script src="http://cdn.bootcss.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
</head>
<body onload="main()">

<!-- 模态框（Modal） -->
<div class="modal fade" id="myModal" tabindex="-1" role="dialog"
     aria-labelledby="myModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">

            <div class="modal-body">
                输入答案: <input type="text" name="password" id="answer1"></div>
            <div class="modal-footer">
                <button type="button" class="btn btn-default" data-dismiss="modal">关闭</button>
                <button type="button" class="btn btn-primary" onclick="update()">确认</button>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal -->
</div>



<canvas id="webgl" width="1600" height="1000">
    Please use a browser that supports "canvas"
</canvas>

<div id="test1"></div>
<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    attribute vec4 a_Color;
    attribute vec4 a_Normal;
    attribute vec3 a_TextCord;
    attribute float objectindex;                //index which object
    uniform mat4 u_MvpMatrix;
    uniform mat4 u_ModelMatrix;
    uniform mat4 u_NormalMatrix;
    uniform int u_PickedObject;    
    uniform float u_info5;   //whether pick the object
    varying vec4 v_Color;
    varying vec3 v_TextCord;
	varying float f_pickedObject;
    void main() {
      vec4 vertexPosition = u_ModelMatrix * a_Position;
      vec3 lightDirection0 = normalize(vec3(0, 40, -20) - vec3(vertexPosition));
      vec3 lightDirection =  normalize(vec3(0.0, 3, 0.87) - vec3(vertexPosition));
      vec3 lightDirection2 = vec3(1.0, -0.87, -0.87);
      vec3 lightDirection3 = vec3(-1.0, -0.87, -0.87);
      vec3 lightColor = vec3(0.05, 0.05, 0.05);
      gl_Position = u_MvpMatrix * a_Position;
      vec3 normal = normalize(vec3(u_NormalMatrix * a_Normal));

      float nDotL0 = max(dot(normal, lightDirection0), 0.0);
      vec3 diffuse = vec3(0.1, 0.1, 0.1) * a_Color.rgb * nDotL0;
      vec3 ambient = vec3(0.02, 0.02, 0.02) * a_Color.rgb;
     // v_Color = vec4(diffuse + ambient, a_Color.a);

	  float nDotL = max(dot(normal, lightDirection), 0.0);
      float nDotL2 = max(dot(normal, lightDirection2), 0.0);
      float nDotL3 = max(dot(normal, lightDirection3), 0.0);
	  vec3 diffuse1 = vec3(0.4, 0.4, 0.4) * a_Color.rgb * nDotL;
      vec3 ambient1 = vec3(0.02, 0.02, 0.02) * a_Color.rgb;
	 
	 f_pickedObject=float(u_PickedObject);
	 
     if(u_PickedObject == 1) {                      //we are choosing the object
      if (u_info5==0.0)
      v_Color = vec4(diffuse + ambient+ambient1+diffuse1, objectindex/255.0);
      else v_Color = vec4(diffuse + ambient, objectindex/255.0);           //update the color, the a is the index value
     // v_Color = vec4(diffuse + ambient,1);           //update the color, the a is the index value
    } else {
        if (u_info5==0.0)
        v_Color = vec4(diffuse + ambient+ambient1+diffuse1, a_Color.a);
    else v_Color = vec4(diffuse + ambient, a_Color.a);
    }
      //v_Color = a_Color;
      v_TextCord = a_TextCord;
      //v_Color = vec4(a_Color.rgb * nDotL +a_Color.rgb * nDotL2+a_Color.rgb * nDotL3, a_Color.a);
      //v_Color = vec4(a_Color.rgb * nDotL + lightColor * a_Color.rgb , a_Color.a);
    }
</script>

<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision mediump float;
    #endif
    varying vec3 v_TextCord;
    varying vec4 v_Color;
    uniform sampler2D u_Sampler;
	varying float f_pickedObject;
    void main() {
		if(f_pickedObject==1.0){
			gl_FragColor=v_Color;
		}
		else{
			if(v_TextCord.z==1.0){
			gl_FragColor = texture2D(u_Sampler, v_TextCord.xy);
			}else{
			gl_FragColor = v_Color;
			}
		}
	}
</script>

<script src="../webgl-utils.js"></script>
<script src="../webgl-debug.js"></script>
<script src="../cuon-utils.js"></script>
<script src="../cuon-matrix.js"></script>
<script src="new_readObj1.js"></script>
<script src="../socket.io.js"></script>

<script>
    const MAX = 65532;

    var modelObject = [];
    var mtlArray = [];
    var objArray = [];
    var TextureArray = [];
    var loadTextures = {unload:0};//加载纹理状态锁,0表示没有待加载的纹理，可以绘制了
    var g_modelMatrix = new Matrix4();
    var g_mvpMatrix = new Matrix4();
    var g_MvpMatrix = new Matrix4();
    var g_ModelMatrix = new Matrix4();
    var g_normalMatrix = new Matrix4();

	var g_premodelMatrix = [];		// 导入物体的位移
	g_premodelMatrix[0] = new Matrix4();
	g_premodelMatrix[1] = new Matrix4();
	g_premodelMatrix[2] = new Matrix4();
	g_premodelMatrix[3] = new Matrix4();
	g_premodelMatrix[4] = new Matrix4();
	g_premodelMatrix[5] = new Matrix4();
	g_premodelMatrix[6] = new Matrix4();
	g_premodelMatrix[7] = new Matrix4();
	g_premodelMatrix[0].setTranslate(0.0, 0.0, 0.0);
	g_premodelMatrix[1].setTranslate(-20.0, -10.0, 65.0);	// 书柜
	g_premodelMatrix[2].setTranslate(20.0, -10.0, -50.0);	// 鞋柜？
	g_premodelMatrix[3].setTranslate(-123.0, -4.0, 60.0);	// 侧着的架子
	g_premodelMatrix[3].rotate(90.0, 0.0, 1.0, 0.0);
	g_premodelMatrix[4].setTranslate(-6.8, 10, 66);			// 书
	g_premodelMatrix[5].setScale(0.01, 1, 1);	
	g_premodelMatrix[5].translate(0, 12.5, 100);			// 立方体
	g_premodelMatrix[6].setScale(0.01, 1, 1);	
	g_premodelMatrix[6].translate(-12000, 12.5, -30);			// 立方体
	g_premodelMatrix[7].setScale(0.01, 1, 0.5);
	g_premodelMatrix[7].translate(-12900, 0, -20);
	

    // Camera表示人的位置，View表示视线方向
	var CameraX = 0.0;
	var CameraY = 10.0;
	var CameraZ = 200.0;
	var ViewX = 0.0;
	var ViewY = 0.0;
	var ViewZ = 100.0;

    var Angle = [0.0, 0.0];

    var viewProjMatrix = new Matrix4();
    var canvas;

    //整合
    var model;
    var gl;
    var currentAngle;

    var SOCKET_URL = "http://192.168.1.109:3000";

	var socket = io.connect(SOCKET_URL);

	socket.on('connect',function(){
    console.log('connected');
});
	socket.on("event",function(data){

    if(data=="doorOpen"){
        info = 0;
		alert("轰隆！有什么东西被打开了！")
    } else if (data == 'electricity') {
        info5=0;
    }

});
	
    var jjjj = 0;
	var set1 = 1;
	var set2 = 1;
	var set3 = 1;
	var info = 1;
	var info_1 = 1;	// 0时传给别人
    var info5=1;
    //需要绑定this 这里面的this就是对于每一个模型来说总的内容的实例
    //这个函数实际上并没有优化的很好,现在只是相当于列出,但是这种方式比较方便
    function getDrawingInfo(ifTexture,objecctIndex) {
        // Create an arrays for vertex coordinates, normals, colors, and indices
        var numIndices = 0;
        for(var i = 0; i < this.objects.length; i++){
            numIndices += this.objects[i].numIndices;
            //每一个objects[i].numIndices 是它的所有的face的顶点数加起来
        }
        var numVertices = numIndices;
        var vertices = new Float32Array(numVertices * 3);
        var normals = new Float32Array(numVertices * 3);
        var colors = new Float32Array(numVertices * 4);
        var objectindex = new Float32Array(numVertices);

        //这个地方的16是不能转化成32的
        var indices = new Uint16Array(numIndices);

        //尝试增加贴图
        var textureVt = new Float32Array(numVertices * 3);

        // Set vertex, normal, texture and color
        //一个face一个face的遍历
        var index_indices = 0;
        for(i = 0; i < this.objects.length; i++){
            var object = this.objects[i];
            if(jjjj<1)console.log("object.faces.length",object.faces.length,this.objects.length);
            for(var j = 0; j < object.faces.length; j++){
                var face = object.faces[j];
                var color = findColor(this,face.materialName);
                // console.log(face.materialName,color);
                var faceNormal = face.normal;
                for(var k = 0; k < face.vIndices.length; k++){
                    // Set index
                    indices[index_indices] = index_indices%MAX;

                    objectindex[index_indices]=objecctIndex;
                   // console.log(objectIndex);
                    // Copy vertex
                    var vIdx = face.vIndices[k];
                    var vertex = this.vertices[vIdx];
                    vertices[index_indices * 3    ] = vertex.x;
                    vertices[index_indices * 3 + 1] = vertex.y;
                    vertices[index_indices * 3 + 2] = vertex.z;

                    var tIdx = face.tIndices[k];
                    var Tvertex = this.textureVt[tIdx];
                    if(!!Tvertex) {
                        textureVt[index_indices * 3] = Tvertex.x;
                        textureVt[index_indices * 3 + 1] = Tvertex.y;
                        textureVt[index_indices * 3 + 2] = ifTexture;
                    }
                    else{
                        //有些是没有纹理坐标的,这个时候把纹理坐标置成系统默认值
                        textureVt[index_indices * 3] = 0;
                        textureVt[index_indices * 3 + 1] = 0;
                        textureVt[index_indices * 3 + 2] = ifTexture;
                    }

                    // Copy color
                    colors[index_indices * 4    ] = color.r;
                    colors[index_indices * 4 + 1] = color.g;
                    colors[index_indices * 4 + 2] = color.b;
                    colors[index_indices * 4 + 3] = color.a;
                    // console.log(colors,color);
                    // Copy normal
                    var nIdx = face.nIndices[k];
                    if(nIdx >= 0){
                        var normal = this.normals[nIdx];
                        normals[index_indices * 3    ] = normal.x;
                        normals[index_indices * 3 + 1] = normal.y;
                        normals[index_indices * 3 + 2] = normal.z;
                    }else{
                        normals[index_indices * 3    ] = faceNormal.x;
                        normals[index_indices * 3 + 1] = faceNormal.y;
                        normals[index_indices * 3 + 2] = faceNormal.z;
                    }
                    index_indices ++;
                }
                jjjj++;
            }
        }
        return new DrawingInfo(vertices, normals, colors, indices, textureVt,objectindex);                      //js 有这种写法的吗
    }

    var ready = true;

    //最多绘制65535个点，这里面的其他内容，都是和indices有倍数关系的，要改变indices的同时也要改变其他的
    function onReadComplete(gl, model, target,begin,numbers,ifTexture,index) {
        // Acquire the vertex coordinates and colors from OBJ file
        //console.log("target",target);
        var drawingInfo = getDrawingInfo.call(target,ifTexture,index);
        if(ready) {
            console.log(drawingInfo, "drawingInfo");
            ready = !ready;
        }
        // Write date into the buffer object
        gl.bindBuffer(gl.ARRAY_BUFFER, model.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.vertices.slice(begin*3,(begin+numbers)*3), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.normals.slice(begin*3,(begin+numbers)*3), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, model.colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.colors.slice(begin*4,(begin+numbers)*4), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, model.textBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.textureVt.slice(begin*3,(begin+numbers)*3), gl.STATIC_DRAW);


        //indicate which object it is for the picket
        gl.bindBuffer(gl.ARRAY_BUFFER, model.objectindexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.objectindex.slice(begin,(begin+numbers)), gl.STATIC_DRAW);


        // Write the indices to the buffer object
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, drawingInfo.indices.slice(begin,begin+numbers), gl.STATIC_DRAW);

        return drawingInfo;
    }

    function ShaderSourceFromScript(scriptID){
        var shaderScript = document.getElementById(scriptID);
        if (shaderScript == null) return "";

        var sourceCode = "";
        var child = shaderScript.firstChild;
        while (child)
        {
            if (child.nodeType == child.TEXT_NODE ) sourceCode += child.textContent;
            child = child.nextSibling;
        }

        return sourceCode;
    }


    var VSHADER_SOURCE = ShaderSourceFromScript("shader-vs");

    // Fragment shader program
    var FSHADER_SOURCE = ShaderSourceFromScript("shader-fs");


    function main() {

        // Retrieve <canvas> element
        canvas = document.getElementById('webgl');

        // Get the rendering context for WebGL
        gl = getWebGLContext(canvas);
        if (!gl) {
            console.log('Failed to get the rendering context for WebGL');
            return;
        }

        // Initialize shaders
        if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
            console.log('Failed to intialize shaders.');
            return;
        }

        // Set the clear color and enable the depth test
        gl.clearColor(0.2, 0.2, 0.2, 1.0);
        gl.enable(gl.DEPTH_TEST);	// 开启隐藏面消除

        // Get the storage locations of attribute and uniform variables
        var program = gl.program;
        program.a_Position = gl.getAttribLocation(program, 'a_Position');
        program.a_Normal = gl.getAttribLocation(program, 'a_Normal');
        program.a_Color = gl.getAttribLocation(program, 'a_Color');
        program.a_TextCord = gl.getAttribLocation(program, 'a_TextCord');
        program.objectindex = gl.getAttribLocation(program,'objectindex');
        program.u_MvpMatrix = gl.getUniformLocation(program, 'u_MvpMatrix');
        program.u_NormalMatrix = gl.getUniformLocation(program, 'u_NormalMatrix');
        program.u_ModelMatrix = gl.getUniformLocation(program, 'u_ModelMatrix');
        program.u_PickedObject = gl.getUniformLocation(program, 'u_PickedObject');
        program.u_info5 = gl.getUniformLocation(program, 'u_info5');

        if (program.a_Position < 0 ||  program.a_Normal < 0 || program.a_Color < 0 || program.a_TextCord <0 ||
            !program.u_MvpMatrix || !program.u_NormalMatrix) {
            console.log('attribute, uniform失败');
            return;
        }

        // Prepare empty buffer objects for vertex coordinates, colors, and normals
        // 建立一堆空缓冲区等待obj文件的数据，具体建立步骤在initVertexBuffers函数内部，由自己实现
        model = initVertexBuffers(gl, program);
        if (!model) {
            console.log('Failed to set the vertex information');
            return;
        }

        // 投影行列計算
        // 设置视图矩阵与投影矩阵vp
        viewProjMatrix = new Matrix4();
        viewProjMatrix.setPerspective(40.0, canvas.width/canvas.height, 1.0, 5000.0);
        viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
        document.onkeydown = function(ev) {keydown(ev); };	// 注册键盘事件响应函数

        // Start reading the OBJ file
        //readOBJFile('../resources/ChairSwing.obj', modelObject,  mtlArray, objArray, 100, false, 0);
        // TextureArray存的是自定义的一些是否加载纹理的信息；modelObject存的是obj文件的信息
        readOBJFile('./cube.obj', modelObject,  mtlArray, objArray, 10, false, 0);
        TextureArray[0]={ifTexture:0.0,TextureUrl:'./Monet.bmp',n:0};
		readOBJFile('./052.obj', modelObject,  mtlArray, objArray, 0.5, false, 1);
		TextureArray[1]={ifTexture:0.0,TextureUrl:'./Crack.bmp',n:1};
		readOBJFile('./054.obj', modelObject,  mtlArray, objArray, 0.5, false, 2);
		TextureArray[2]={ifTexture:0.0,TextureUrl:'./Monet.bmp',n:2};
		readOBJFile('./051.obj', modelObject,  mtlArray, objArray, 0.5, false, 3);
		TextureArray[3]={ifTexture:0.0,TextureUrl:'./Crack.bmp',n:3};
		readOBJFile('./045.obj', modelObject,  mtlArray, objArray, 0.5, false, 4);
		TextureArray[4]={ifTexture:0.0,TextureUrl:'./Crack.bmp',n:4};
		readOBJFile('./Cube1.obj', modelObject,  mtlArray, objArray, 10, false, 5);
        TextureArray[5]={ifTexture:1.0,TextureUrl:'./code.bmp',n:5};
		readOBJFile('./Cube1.obj', modelObject,  mtlArray, objArray, 10, false, 6);
        TextureArray[6]={ifTexture:1.0,TextureUrl:'./code1.bmp',n:6};
		readOBJFile('./Cube1.obj', modelObject,  mtlArray, objArray, 20, false, 7);
        TextureArray[7]={ifTexture:0.0,TextureUrl:'./code3.bmp',n:7};
        //1.0代表加载纹理，0.0代表不加载纹理; n表示纹理编号

      currentAngle = [0.0, 0.0]; // Current rotation angle ([x-axis, y-axis] degrees)
      initEventHandlers(canvas);	// 鼠标控制物体旋转，切换视角
     //  gl.uniform1i(program.u_PickedObject, -1);                   //初始没有选中
        // 动画绘制
        var tick = function() {   // Start drawing
            // currentAngle = animate(currentAngle); // Update current rotation angle
            if(loadTextures.unload<=0){	// loadTextures是纹理锁，小于0表示没有待加载的纹理了，可以开始绘制了
                initDraw(gl);
                for(var ii=0;ii<modelObject.length;ii++){
                    draw(gl, gl.program, currentAngle, viewProjMatrix, model, ii, TextureArray);
                    // gl是该webgl的上下文，gl.program表示着色器链接，currentAngle表示当前物体的旋转角
                    // viewProjMatrix表示vp视角矩阵，model表示要绘制对象(缓冲区)的个数/长度；
                    // ii表示第ii个obj文件即即将绘制第ii个物体；TextureArray存的是一些纹理加载信息
                }
            }
            requestAnimationFrame(tick, canvas);
        };


        for(var ii=0;ii<TextureArray.length;ii++){
            if(TextureArray[ii].ifTexture==1.0){
                loadTextures.unload++;
                initTextures(gl,TextureArray[ii]);
            }
        }
        initDraw(gl);	// 清除颜色与深度缓存
        tick();

    };

   function keydown(ev) {
		viewProjMatrix = new Matrix4();
		viewProjMatrix.setPerspective(40.0, canvas.width/canvas.height, 1.0, 5000.0);
		// 计算当前运动方向
		var mylen = Math.sqrt((ViewZ - CameraZ)*(ViewZ - CameraZ)+(ViewX - CameraX)*(ViewX - CameraX));
		var mysin = (ViewZ - CameraZ)/mylen;
		var mycos = (ViewX - CameraX)/mylen;
		var flag = 1;
		if (CameraX<-110 && CameraZ>-20 && CameraZ<0 && set3 == 0)
		{
			alert("You Win!");
            socket.emit('event','over3');
            window.location=SOCKET_URL;
			//......
		}
		
		// 根据键盘控制与当前运动方向可以计算走一步之后的位置与视点
		if (ev.keyCode == 39) {			// The right arrow key was pressed
		    CameraZ += 6 * mycos;
			CameraX -= 6 * mysin;
			if (CameraZ<=60 && CameraZ-6*mycos>60 && CameraX >-65)	// 内墙1的碰撞检测
				flag=0;
			if (CameraZ>=55 && CameraZ-6*mycos<55 && CameraX >-65)
				flag=0;
			if (CameraZ<=-55 && CameraZ-6*mycos>-55 && CameraX <65)	// 内墙2的碰撞检测
				flag=0;
			if (CameraZ>=-60 && CameraZ-6*mycos<-60 && CameraX <65)
				flag=0;
			//if (...)
				/*if (CameraZ<=2.5 && CameraZ-6*mycos>2.5)	// 内墙3的碰撞检测
					flag=0;
				if (CameraZ>=-2.5 && CameraZ-6*mycos<-2.5)
					flag=0;*/
			// if (...)
				if (CameraZ<=2.5 && CameraZ-6*mycos>2.5 && (CameraX < -18 || CameraX > 18))	// 内墙3的碰撞检测
					flag=0;
				if (CameraZ>=-2.5 && CameraZ-6*mycos<-2.5 && (CameraX < -18 || CameraX > 18))
					flag=0;
			if (CameraZ>=-205 && CameraZ<=205 && CameraX>=-115 && CameraX<=115 && flag==1) {
				ViewX = -Math.sin(Angle[1]/180.0*3.1415926)*100.0+CameraX;
				if (Angle[1]>-90 && Angle[1] < 90)
					ViewZ = -Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;	
				else ViewZ = Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;
			}
			else {
				CameraZ -= 6 * mycos;
				CameraX += 6 * mysin;
			}
            console.log(1);
            viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
        } else if (ev.keyCode == 37) { 	// The left arrow key was pressed
            CameraZ -= 6 * mycos;
			CameraX += 6 * mysin;
			if (CameraZ<=60 && CameraZ+6*mycos>60 && CameraX >-65)
				flag=0;
			if (CameraZ>=55 && CameraZ+6*mycos<55 && CameraX >-65)
				flag=0;
			if (CameraZ<=-55 && CameraZ+6*mycos>-55 && CameraX <65)
				flag=0;
			if (CameraZ>=-60 && CameraZ+6*mycos<-60 && CameraX <65)
				flag=0;
				/*if (CameraZ<=2.5 && CameraZ+6*mycos>2.5)	// 内墙3的碰撞检测
					flag=0;
				if (CameraZ>=-2.5 && CameraZ+6*mycos<-2.5)
					flag=0;*/
				if (CameraZ<=2.5 && CameraZ+6*mycos>2.5 && (CameraX < -18 || CameraX > 18))	// 内墙3的碰撞检测
					flag=0;
				if (CameraZ>=-2.5 && CameraZ+6*mycos<-2.5 && (CameraX < -18 || CameraX > 18))
					flag=0;
			if (CameraZ>=-205 && CameraZ<=205 && CameraX>=-115 && CameraX<=115 && flag==1) {
				ViewX = -Math.sin(Angle[1]/180.0*3.1415926)*100.0+CameraX;
				if (Angle[1]>-90 && Angle[1] < 90)
					ViewZ = -Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;	
				else ViewZ = Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;
			}
			else {
				CameraZ += 6 * mycos;
				CameraX -= 6 * mysin;
			}
            viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
        }else if (ev.keyCode == 40) { 	// The back arrow key was pressed
            CameraZ -= 6 * mysin;
			CameraX -= 6 * mycos;
			if (CameraZ<=60 && CameraZ+6*mysin>60 && CameraX >-65)
				flag=0;
			if (CameraZ>=55 && CameraZ+6*mysin<55 && CameraX >-65)
				flag=0;
			if (CameraZ<=-55 && CameraZ+6*mysin>-55 && CameraX <65)
				flag=0;
			if (CameraZ>=-60 && CameraZ+6*mysin<-60 && CameraX <65)
				flag=0;
			/*if (CameraZ<=2.5 && CameraZ+6*mysin>2.5)	// 内墙3的碰撞检测
				flag=0;
			if (CameraZ>=-2.5 && CameraZ+6*mysin<-2.5)
				flag=0;*/
				if (CameraZ<=2.5 && CameraZ+6*mysin>2.5 && (CameraX < -18 || CameraX > 18))	// 内墙3的碰撞检测
					flag=0;
				if (CameraZ>=-2.5 && CameraZ+6*mysin<-2.5 && (CameraX < -18 || CameraX > 18))
					flag=0;
			if (CameraZ>=-205 && CameraZ<=205 && CameraX>=-115 && CameraX<=115 && flag==1) {
				ViewX = -Math.sin(Angle[1]/180.0*3.1415926)*100.0+CameraX;
				if (Angle[1]>-90 && Angle[1] < 90)
					ViewZ = -Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;	
				else ViewZ = Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;
			}
			else {
				CameraZ += 6 * mysin;
				CameraX += 6 * mycos;
			}
            viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
        }
        else if (ev.keyCode == 38) { 	// The front arrow key was pressed
            CameraZ += 6 * mysin;
			CameraX += 6 * mycos;
			if (CameraZ<=60 && CameraZ-6*mysin>60 && CameraX >-65)
				flag=0;
			if (CameraZ>=55 && CameraZ-6*mysin<55 && CameraX >-65)
				flag=0;
			if (CameraZ<=-55 && CameraZ-6*mysin>-55 && CameraX <65)
				flag=0;
			if (CameraZ>=-60 && CameraZ-6*mysin<-60 && CameraX <65)
				flag=0;
			/*if (CameraZ<=2.5 && CameraZ-6*mysin>2.5)	// 内墙3的碰撞检测
				flag=0;
			if (CameraZ>=-2.5 && CameraZ-6*mysin<-2.5)
				flag=0;*/
				if (CameraZ<=2.5 && CameraZ-6*mysin>2.5 && (CameraX < -18 || CameraX > 18))	// 内墙3的碰撞检测
					flag=0;
				if (CameraZ>=-2.5 && CameraZ-6*mysin<-2.5 && (CameraX < -18 || CameraX > 18))
					flag=0;
			if (CameraZ>=-205 && CameraZ<=205 && CameraX>=-115 && CameraX<=115 && flag==1) {
				ViewX = -Math.sin(Angle[1]/180.0*3.1415926)*100.0+CameraX;
				if (Angle[1]>-90 && Angle[1] < 90)
					ViewZ = -Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;	
				else ViewZ = Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;
			}
			else {
				CameraZ -= 6 * mysin;
				CameraX -= 6 * mycos;
			}
            viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
        }
        else {
			viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
            return;
        }
	}
        

    // 鼠标控制旋转
    function initEventHandlers(canvas) {
        var dragging = false;         // Dragging or not
        var lastX = -1, lastY = -1;   // Last position of the mouse

		canvas.onmousedown =  function (ev) {   // Mouse is pressed             //为什么内部的参数不需要传进去
            var flag =true;
            var x = ev.clientX, y = ev.clientY;
            var rect = ev.target.getBoundingClientRect();
            if (rect.left <= x && x < rect.right && rect.top <= y && y < rect.bottom) {
                // If Clicked position is inside the <canvas>, update the selected surface
                var x_in_canvas = x - rect.left, y_in_canvas = rect.bottom - y;
                var face = checkObject( x_in_canvas, y_in_canvas, currentAngle, viewProjMatrix,  model);

                 if(face==2){
					//$('#myModal').modal();
                     if (CameraX<-80 && CameraZ<100 && set3 == 0)
					 {
						alert("Just go ahead and\n Win!");
					 }
					 else {alert("Don't touch me!");}
                     flag=false;
;                 }
				else if (face==1)
				{
					alert("Come and read some books!");
					flag=false;
				}
				else if (face==4)
				{
					if (CameraX>-15&&CameraZ<120)	
					{
						set1 = 0;
						alert("Dragging!\nWOW!\n\nThere is something on the wall!\n\n    ");
					}
					else {alert("Which book do you want to read?");}
					flag=false;
				}
				else if (face==3)
				{
					if (CameraZ<-165 && CameraX<-80)
					{
						alert("Please search for another picture and solve the problem on it!");
						set2 = 0;
					}
					else {alert("I am tall!");}
					flag=false;
				}
				else if (face==5)
				{
					flag=false;
					var name = prompt("请输入你的行列式结果：", ""); //将输入的内容赋给变量 name ， 
					if (name==6)//如果返回的有内容 
					{ 
						alert("Congradulations! Your answer is right! You have sent a useful message to your partner!");
						info_1 = 0;
						socket.emit('event', 'qrOn' );
					} 
					else alert("Sorry, your answer is wrong. Please study harder in the following days!");
				}
				else if (face==6)
				{
					flag=false;
					var name = prompt("请输入你的答案：", "");
					if (name=='F' || name=='f')//如果返回的有内容 
					{ 
						alert("Congradulations! Your answer is right!\n\nNow you just need to go straight and succeed escaping!");
						set3 = 0;
					} 
					else alert("Sorry, your answer is wrong. Please think seriously again!");
				}
                //    TextureArray[1]={ifTexture:1.0,TextureUrl:'./1.bmp',n:0};
                //  readOBJFile('./001.obj', modelObject,  mtlArray, objArray, 2, false, 0);
                // }

              //  alert(face +"objece is choosed");
                gl.uniform1i(gl.program.u_PickedObject, -1);
                Draw(gl,  currentAngle, viewProjMatrix, model,  TextureArray);
                //draw(gl, n, currentAngle, viewProjMatrix, u_MvpMatrix);
                if(flag) {
                    dragging = true;
                }
            }
        }

        canvas.onmouseup = function(ev) { dragging = false;  }; // Mouse is released

		canvas.onmousemove = function(ev) { // Mouse is moved
            var x = ev.clientX, y = ev.clientY;
            if (dragging) {
				viewProjMatrix = new Matrix4();
				viewProjMatrix.setPerspective(40.0, canvas.width/canvas.height, 1.0, 5000.0);
                var factor = 100/canvas.height; // 使dx和dy与<canvas>自身大小无关
                var dx = factor * (x - lastX);
                var dy = factor * (y - lastY);
				// 视点在以观察者位置为圆心，100为半径的球上移动
				Angle[0] = Math.max(Math.min(Angle[0] + dy, 90.0), -90.0);
                Angle[1] = Angle[1] + dx;
				if (Angle[1]>180.0)
					Angle[1] -= 360.0;
				if (Angle[1]<-180.0)
					Angle[1] += 360.0;
				// ViewY += dy;
				// ViewX -= dx;
				ViewX = -Math.sin(Angle[1]/180.0*3.1415926)*100.0+CameraX;
				ViewY = Math.sin(Angle[0]/180.0*3.1415926)*100.0;
				if (Angle[1]>-90 && Angle[1] < 90)
					ViewZ = -Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;	
				else ViewZ = Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;
                // Limit x-axis rotation angle to -90 to 90 degrees
                // currentAngle[0] = Math.max(Math.min(currentAngle[0] + dy, 90.0), -90.0);
                // currentAngle[1] = currentAngle[1] + dx;
				viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
            }
            lastX = x, lastY = y;
        };
    }



    // Create an buffer object and perform an initial configuration
    // 创建多个空缓冲区并初始化，使得每个attribute都能有自己的缓冲区传数据到着色器
    function initVertexBuffers(gl, program) {
        var o = new Object(); // Utilize Object object to return multiple buffer objects
        o.vertexBuffer = createEmptyArrayBuffer(gl, program.a_Position, 3, gl.FLOAT);
        o.normalBuffer = createEmptyArrayBuffer(gl, program.a_Normal, 3, gl.FLOAT);
        o.colorBuffer = createEmptyArrayBuffer(gl, program.a_Color, 4, gl.FLOAT);
        o.textBuffer = createEmptyArrayBuffer(gl, program.a_TextCord, 3, gl.FLOAT);
        o.objectindexBuffer = createEmptyArrayBuffer(gl, program.objectindex, 1, gl.FLOAT);
        o.indexBuffer = gl.createBuffer();

        if (!o.vertexBuffer || !o.normalBuffer || !o.textBuffer || !o.colorBuffer || !o.indexBuffer) { return null; }

        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        return o;
    }

    // Create a buffer object, assign it to attribute variables, and enable the assignment
    // 具体创建缓冲区过程，其中a_attribute在main函数开头已设好着色器地址
    function createEmptyArrayBuffer(gl, a_attribute, num, type) {
        var buffer =  gl.createBuffer();  // Create a buffer object
        if (!buffer) {
            console.log('Failed to create the buffer object');
            return null;
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(a_attribute, num, type, true, 0, 0);  // Assign the buffer object to the attribute variable
        gl.enableVertexAttribArray(a_attribute);  // Enable the assignment

        return buffer;
    }

    //这里面的n应该是标号，只不过暂时没有用到
    function initTextures(gl,thisTexture) {
        console.log(gl,"image to onload ..",gl);
        var texture = gl.createTexture();   // Create a texture object
        if (!texture) {
            console.log('Failed to create the texture object');
            return false;
        }

        // Get the storage location of u_Sampler
        var u_Sampler = gl.getUniformLocation(gl.program, 'u_Sampler');
        //console.log("u_Sampler",u_Sampler);
        if (!u_Sampler) {
            console.log('Failed to get the storage location of u_Sampler');
            return false;
        }
        var image = new Image();  // Create the image object
        if (!image) {
            console.log('Failed to create the image object');
            return false;
        }
        // Register the event handler to be called on loading an image
        image.onload = function(){
            console.log("image onload");
            loadTexture(gl, thisTexture.n, texture, u_Sampler, image);
        };
        // Tell the browser to load an image
        image.src = thisTexture.TextureUrl;

        return true;
    }

    function loadTexture(gl, n, texture, u_Sampler, image) {
        var TextureList = [gl.TEXTURE0,gl.TEXTURE1,gl.TEXTURE2,gl.TEXTURE3,gl.TEXTURE4,gl.TEXTURE5,gl.TEXTURE6,gl.TEXTURE7];

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // Flip the image's y axis
        // Enable texture unit0
        gl.activeTexture(TextureList[n]);
        // Bind the texture object to the target
        gl.bindTexture(gl.TEXTURE_2D, texture);

        // Set the texture parameters
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        // Set the texture image
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);

        loadTextures.unload-=1;
        // Set the texture unit 0 to the sampler
        // gl.uniform1i(u_Sampler, n);
    }


    var tttt = 0;

    // 开始绘制前，清除颜色与深度缓存
    function initDraw(gl){
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);  // Clear color and depth buffers
        gl.uniform1f(gl.program.u_info5,info5);
    }

    // 描画関数
    // gl是该webgl的上下文，program表示着色器链接，angle表示当前物体的旋转角
    // viewProjMatrix表示vp视角矩阵，model表示要绘制对象(缓冲区)的个数/长度(一个物体的参数数量)；
    // index表示第ii个obj文件；TextureArray存的是一些纹理信息
    function draw(gl, program, angle, viewProjMatrix, model, index, TextureArray) {

        if(!objArray[index]){
            console.log("no object!!!");
            return;
        }

        if(TextureArray[index].ifTexture==1.0){		// 如果等于1，说明要加载纹理
            var u_Sampler = gl.getUniformLocation(gl.program, 'u_Sampler');
            gl.uniform1i(u_Sampler, TextureArray[index].n);
        }

        var numIndices = 0;
        for(var i = 0; i < modelObject[index].objects.length; i++){
            numIndices += modelObject[index].objects[i].numIndices;
            //每一个objects[i].numIndices 是它的所有的face的顶点数加起来
        }

        console.log(modelObject,"modelObject");


        for(var ii=0;ii<Math.ceil(numIndices/MAX);ii++){
            if(tttt<1)console.log("when tttt < 1",numIndices,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX);
            g_drawingInfo = onReadComplete(gl, model, modelObject[index],ii*MAX,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX,TextureArray[index].ifTexture,index);
            g_objDoc = null;
            g_modelMatrix.setRotate(angle[0], 1.0, 0.0, 0.0); // 设置模型旋转矩阵
            g_modelMatrix.rotate(angle[1], 0.0, 1.0, 0.0);

            g_mvpMatrix.set(viewProjMatrix);

            // Calculate the normal transformation matrix and pass it to u_NormalMatrix
            g_normalMatrix.setInverseOf(g_modelMatrix);
            g_normalMatrix.transpose();
            gl.uniformMatrix4fv(program.u_NormalMatrix, false, g_normalMatrix.elements);
            gl.uniformMatrix4fv(program.u_ModelMatrix, false, g_modelMatrix.elements);

            // Calculate the model view project matrix and pass it to u_MvpMatrix
            // g_mvpMatrix.multiply(g_modelMatrix);
            //g_mvpMatrix.setOrtho(-100,100,-100,100,-50,50);
            g_mvpMatrix.multiply(g_modelMatrix);
            g_mvpMatrix.multiply(g_premodelMatrix[index]);
            /*if (index == 1) {
             g_mvpMatrix.multiply(aa);
             }
             else if (index == 2) {
             g_mvpMatrix.multiply(bb);
             }*/

            if (index == 0) {	// 墙
				g_MvpMatrix.set(g_mvpMatrix);	// 不能直接等于
				g_ModelMatrix.setTranslate(0.0, 0.0, -210.0);
				g_ModelMatrix.scale(30.0, 30.0, 0.1);	// 先让物体在原点缩放再进行平移，不然缩放会影响坐标位置；且后方较远，x方向放大得多一点
				g_MvpMatrix.multiply(g_ModelMatrix);
				gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
				gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
				
				g_MvpMatrix.set(g_mvpMatrix);	// 后墙
				g_ModelMatrix.setTranslate(0.0, 0.0, 210.0);
				g_ModelMatrix.scale(30.0, 30.0, 0.1);	
				g_MvpMatrix.multiply(g_ModelMatrix);				 
				gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
				gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
				
				g_MvpMatrix.set(g_mvpMatrix);	// 下墙
				g_ModelMatrix.setTranslate(0.0, -10.0, 0.0);
				g_ModelMatrix.scale(30.0, 0.1, 30.0);	
				g_MvpMatrix.multiply(g_ModelMatrix);		
				//g_mvpMatrix.scale(1.0, 1.0, 10.0);			 
				gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
				gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
				
				g_MvpMatrix.set(g_mvpMatrix);	// 上墙
				g_ModelMatrix.setTranslate(0.0, 30.0, 0.0);
				g_ModelMatrix.scale(30.0, 0.1, 30.0);	
				g_MvpMatrix.multiply(g_ModelMatrix);		
				//g_mvpMatrix.scale(1.0, 1.0, 10.0);			 
				gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
				gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
				
				g_MvpMatrix.set(g_mvpMatrix);	// 左墙
				g_ModelMatrix.setTranslate(-130.0, 0.0, 0.0);
				g_ModelMatrix.scale(0.1, 30.0, 30.0);	
				g_MvpMatrix.multiply(g_ModelMatrix);		
				//g_mvpMatrix.scale(1.0, 1.0, 10.0);			 
				gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
				gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
				
				g_MvpMatrix.set(g_mvpMatrix);	// 右墙
				g_ModelMatrix.setTranslate(130.0, 0.0, 0.0);
				g_ModelMatrix.scale(0.1, 30.0, 30.0);	
				g_MvpMatrix.multiply(g_ModelMatrix);		
				//g_mvpMatrix.scale(1.0, 1.0, 10.0);			 
				gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
				gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
				
				g_MvpMatrix.set(g_mvpMatrix);	// 内墙1
				g_ModelMatrix.setTranslate(40.0, 0.0, 58.5);
				g_ModelMatrix.scale(10.0, 30.0, 0.1);	
				g_MvpMatrix.multiply(g_ModelMatrix);				 
				gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
				gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
				
				g_MvpMatrix.set(g_mvpMatrix);	// 内墙2
				g_ModelMatrix.setTranslate(-40.0, 0.0, -58.5);
				g_ModelMatrix.scale(10.0, 30.0, 0.1);	
				g_MvpMatrix.multiply(g_ModelMatrix);				 
				gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
				gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
				
				if (info==1)
				{
					g_MvpMatrix.set(g_mvpMatrix);	// 内墙3
					g_ModelMatrix.setTranslate(0.0, 0.0, 0.0);
					g_ModelMatrix.scale(30.0, 30.0, 0.1);	
					g_MvpMatrix.multiply(g_ModelMatrix);				 
					gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
					gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
				}
				
				if (info==0)
				{
					g_MvpMatrix.set(g_mvpMatrix);	// 内墙3左
					g_ModelMatrix.setTranslate(-97.0, 0.0, 0.0);
					g_ModelMatrix.scale(8.0, 30.0, 0.1);	
					g_MvpMatrix.multiply(g_ModelMatrix);				 
					gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
					gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
					
					g_MvpMatrix.set(g_mvpMatrix);	// 内墙3右
					g_ModelMatrix.setTranslate(97.0, 0.0, 0.0);
					g_ModelMatrix.scale(8.0, 30.0, 0.1);	
					g_MvpMatrix.multiply(g_ModelMatrix);				 
					gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
					gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
				}
			}
//            g_mvpMatrix.rotate(angle[0], 1.0, 0.0, 0.0);
//            g_mvpMatrix.rotate(angle[1], 0.0, 1.0, 0.0);
            //g_mvpMatrix.translate(-200.0,0.0,0.0);
			else {	// 一般物体
				if (index!=5 && index != 6 && index != 7){
					g_mvpMatrix.translate(0.0, -9.0, 0.0);
					gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements);

				// Draw
					gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
				}
				
				if (index==6)
				{
					if (set2 == 0)
					{
						gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements);

				// Draw
						gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
					}
				}
				
				if (index==7)
				{
					if (set3==0)
					{
						gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements);

				// Draw
						gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
					}
				}
				
				if (index==4)
				{
					//g_mvpMatrix.rotate(90.0,0.0,1.0,0.0);
					g_mvpMatrix.translate(-17.4,0,0);
					gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements);
					gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
				}
				
				if (index==3)
				{
					//g_mvpMatrix.rotate(90.0,0.0,1.0,0.0);
					g_mvpMatrix.translate(265,0,5);
					g_mvpMatrix.rotate(-90,0,1,0);
					gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements);
					gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
				}
				
				if (index==2)
				{
					g_mvpMatrix.translate(10,0,120);
					//g_mvpMatrix.rotate(-90,0,1,0);
					gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements);
					gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
					
					g_mvpMatrix.translate(-150,0,120);
					g_mvpMatrix.rotate(90,0,1,0);
					gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements);
					gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
					
					if (set3 == 1)
					{
						g_mvpMatrix.translate(200,0,0);
					//g_mvpMatrix.rotate(90,0,1,0);
						gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements);
						gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
					}
				}
				
				if (index==1)
				{
					g_mvpMatrix.translate(100,0,-270);
					//g_mvpMatrix.rotate(-90,0,1,0);
					gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements);
					gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
				}
				
				if (index==5)
				{
					if (set1==0)
					{
						g_mvpMatrix.translate(-12500,0,50);
						//g_mvpMatrix.rotate(-90,0,1,0);
						gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements);
						gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
					}
				}				
			}
        }

        tttt++;

    }

    function Draw(gl,  currentAngle, viewProjMatrix, model,  TextureArray){
        if(loadTextures.unload<=0){
            initDraw(gl);
            for(var ii=0;ii<modelObject.length;ii++){
                draw(gl, gl.program, currentAngle, viewProjMatrix, model,ii,TextureArray);
            }
        }
    }


    function checkObject( x, y, currentAngle,  viewProjMatrix,  model) {
        var pixels = new Uint8Array(4); // Array for storing the pixel value
        gl.uniform1i(gl.program.u_PickedObject, 1);      // Draw by writing surface number into alpha value
        Draw(gl,  currentAngle, viewProjMatrix, model,  TextureArray);                                  //重新画一遍，将objectindex写到rgba 中的a
        // Read the pixel value of the clicked position. pixels[3] is the surface number
        gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

        return pixels[3];
    }

</script>
</body>
</html>