<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>webgl</title>
    <!-- 新 Bootstrap 核心 CSS 文件 -->
    <link rel="stylesheet" href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css">

    <!-- 可选的Bootstrap主题文件（一般不用引入） -->
    <link rel="stylesheet" href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap-theme.min.css">

    <!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->
    <script src="http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>

    <!-- 最新的 Bootstrap 核心 JavaScript 文件 -->
    <script src="http://cdn.bootcss.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
    <script src ="../socket.io.js"></script>
</head>
<body onload="main()">

<audio id="myAudio">

    <source src="openlock.mp3" type="audio/mpeg">
    您的浏览器不支持 audio 与元素。
</audio>
<audio id="openlight">

    <source src="openlight.mp3" type="audio/mpeg">
    您的浏览器不支持 audio 与元素。
</audio>



<canvas id="webgl" width="1600" height="1000">
    Please use a browser that supports "canvas"
</canvas>

<!-- 模态框（Modal） -->
<div class="modal fade" id="myModal" tabindex="-1" role="dialog"
     aria-labelledby="myModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close"
                        data-dismiss="modal" aria-hidden="true">
                    &times;
                </button>
                <h4 class="modal-title" id="myModalLabel">
                    我骑电动车，赶脚像开飞机，两边全是祥云！----请猜一天气
                </h4>
            </div>
            <div class="modal-body">
                输入答案: <input type="text" name="password" id="answer1"></div>
            <div class="modal-footer">
                <button type="button" class="btn btn-default" data-dismiss="modal">关闭</button>
                <button type="button" class="btn btn-primary" onclick="update()">确认</button>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal -->
</div>

<div class="modal fade" id="myModal1" tabindex="-1" role="dialog"
     aria-labelledby="myModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close"
                        data-dismiss="modal" aria-hidden="true">
                    &times;
                </button>
                <h4 class="modal-title" id="myModalLabel1">
                   这个文件盒貌似可以移动，让我们把它放到旁边如何
                </h4>
            </div>

            <div class="modal-footer">
                <button type="button" class="btn btn-primary" onclick="moveBook()">放到旁边</button>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal -->
</div>

<!-- 移动门---还是锁死的 -->

<div class="modal fade" id="myModal2" tabindex="-1" role="dialog"
     aria-labelledby="myModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close"
                        data-dismiss="modal" aria-hidden="true">
                    &times;
                </button>
                <h4 class="modal-title" id="myModalLabel2">
                    这是一个固定的柜橱
                </h4>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal -->
</div>

<!-- 移动门---门可以移动了 -->

<div class="modal fade" id="myModal3" tabindex="-1" role="dialog"
     aria-labelledby="myModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close"
                        data-dismiss="modal" aria-hidden="true">
                    &times;
                </button>
                <h4 class="modal-title" id="myModalLabel3">
                    这个柜橱貌似可以移动，让我们移动看看
                </h4>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal -->
</div>

<!-- 打开其他房间的灯 -->

<div class="modal fade" id="myModal4" tabindex="-1" role="dialog"
     aria-labelledby="myModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close"
                        data-dismiss="modal" aria-hidden="true">
                    &times;
                </button>
                <h4 class="modal-title" id="myModalLabel4">
                    其他房间的灯已经打开
                </h4>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal -->
</div>

<!-- 提示可以移动衣橱了 -->
<div class="modal fade" id="myModal5" tabindex="-1" role="dialog"
     aria-labelledby="myModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close"
                        data-dismiss="modal" aria-hidden="true">
                    &times;
                </button>
                <h4 class="modal-title" id="myModalLabel5">
                    貌似有什么东西打开了
                </h4>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal -->
</div>
<!-- 提示猜谜题 -->
<div class="modal fade" id="myModal6" tabindex="-1" role="dialog"
     aria-labelledby="myModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close"
                        data-dismiss="modal" aria-hidden="true">
                    &times;
                </button>
                <h4 class="modal-title" id="myModalLabel6">
                    上面好像刻了什么字，让我们看一下
                </h4>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" onclick="Seeproblem()">仔细看看</button>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal -->
</div>
<!-- gameover -->
<div class="modal fade" id="myModal7" tabindex="-1" role="dialog"
     aria-labelledby="myModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close"
                        data-dismiss="modal" aria-hidden="true">
                    &times;
                </button>
                <h4 class="modal-title" id="myModalLabel6">
                    You win!
                </h4>
            </div>
            
        </div><!-- /.modal-content -->
    </div><!-- /.modal -->
</div>

<div id="test1"></div>
<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec4 a_Position;
    attribute vec4 a_Color;
    attribute vec4 a_Normal;
    attribute vec3 a_TextCord;
    attribute float objectindex;                //index which object
    uniform mat4 u_MvpMatrix;
    uniform mat4 u_ModelMatrix;
    uniform mat4 u_NormalMatrix;
    uniform int u_PickedObject;           //whether pick the object
  //  uniform float v_flog;                   //是否开启雾化
    uniform vec4 u_Eye;                     //眼睛距离

    varying float v_Dist;
       varying vec4 v_Color;
    varying vec3 v_TextCord;
    varying float f_picketObject;



    void main() {
      vec4 vertexPosition = u_ModelMatrix * a_Position;
      vec3 lightDirection0 = normalize(vec3(0, 0, -100) - vec3(vertexPosition));
      vec3 lightDirection =  normalize(vec3(0, 3, 0.87) - vec3(vertexPosition));
      vec3 lightDirection2 = vec3(1.0, -0.87, -0.87);
      vec3 lightDirection3 = vec3(-1.0, -0.87, -0.87);
      vec3 lightColor = vec3(0.05, 0.05, 0.05);
      gl_Position = u_MvpMatrix * a_Position;
      vec3 normal = normalize(vec3(u_NormalMatrix * a_Normal));

      float nDotL0 = max(dot(normal, lightDirection0), 0.0);
        float nDotL = max(dot(normal, lightDirection), 0.0);


      vec3 diffuse = vec3(0.1, 0.1, 0.1) * a_Color.rgb * nDotL0;
      vec3 ambient = vec3(0.02, 0.02, 0.02) * a_Color.rgb;

      vec3 diffuse1 =vec3(0.4, 0.4, 0.4) * a_Color.rgb * nDotL;
      vec3 ambient1 =vec3(0.02, 0.02, 0.02) * a_Color.rgb;


     // v_Color = vec4(diffuse + ambient, a_Color.a);

     if(u_PickedObject == 1) {                      //we are choosing the object
      v_Color = vec4(diffuse + ambient+diffuse1 + ambient1, objectindex/255.0);           //update the color, the a is the index value
     // v_Color = vec4(diffuse + ambient,1);           //update the color, the a is the index value
    } else {
        v_Color = vec4(diffuse + ambient+diffuse1 + ambient1, a_Color.a);
    }

     //for fog

     v_Dist = distance(u_ModelMatrix * a_Position, u_Eye);

     f_picketObject=float(u_PickedObject);

      float nDotL2 = max(dot(normal, lightDirection2), 0.0);
      float nDotL3 = max(dot(normal, lightDirection3), 0.0);
      //v_Color = a_Color;
      v_TextCord = a_TextCord;
      //v_Color = vec4(a_Color.rgb * nDotL +a_Color.rgb * nDotL2+a_Color.rgb * nDotL3, a_Color.a);
      //v_Color = vec4(a_Color.rgb * nDotL + lightColor * a_Color.rgb , a_Color.a);
    }
</script>

<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision mediump float;
    #endif
    varying vec3 v_TextCord;

    varying vec4 v_Color;

    varying float v_Dist;
    varying float f_picketObject;



    uniform vec3 u_FogColor;  // Color of Fog
    uniform vec2 u_FogDist;   // Distance of Fog (starting point, end point)
    uniform int fog;

    uniform sampler2D u_Sampler;
    void main() {

    if(f_picketObject==1.0){
        gl_FragColor=v_Color;
    }
    else{
        if(fog==0){
         float fogFactor = clamp((u_FogDist.y - v_Dist) / (u_FogDist.y - u_FogDist.x), 0.0, 1.0);
         vec3 fcolor = mix(u_FogColor, vec3(v_Color), fogFactor);
         //gl_FragColor=vec4(1.0,0.0,0.0,1.0);
         gl_FragColor = vec4(fcolor, v_Color.a);
        }
        else{
            if(v_TextCord.z==1.0){
                gl_FragColor = texture2D(u_Sampler, v_TextCord.xy);
            }else{
                gl_FragColor = v_Color;
               // console.log(gl_FragColor);
            }
        }
    }
    }
</script>









<script src="../webgl-utils.js"></script>
<script src="../webgl-debug.js"></script>
<script src="../cuon-utils.js"></script>
<script src="../cuon-matrix.js"></script>
<script src="new_readObj.js"></script>

<script>
    const MAX = 65532;

    var modelObject = [];
    var mtlArray = [];
    var objArray = [];
    var TextureArray = [];
    var loadTextures = {unload:0};//加载纹理状态锁,0表示没有待加载的纹理，可以绘制了
    var g_modelMatrix = new Matrix4();
    var g_mvpMatrix = new Matrix4();
    var g_MvpMatrix = new Matrix4();
    var g_ModelMatrix = new Matrix4();
    var g_normalMatrix = new Matrix4();

    var g_premodelMatrix = [];		// 导入物体的位移
    g_premodelMatrix[0] = new Matrix4();
    g_premodelMatrix[1] = new Matrix4();
    g_premodelMatrix[2] = new Matrix4();
    g_premodelMatrix[3] = new Matrix4();
    g_premodelMatrix[4] = new Matrix4();
    g_premodelMatrix[5] = new Matrix4();
    g_premodelMatrix[6] = new Matrix4();
    g_premodelMatrix[7] = new Matrix4();
    g_premodelMatrix[8] = new Matrix4();


    g_premodelMatrix[0].setTranslate(0.0, 0.0, 0.0);
    g_premodelMatrix[1].setTranslate(-67.0, 0.0, 0.0);
    g_premodelMatrix[1].rotate(90,0,1,0 );
    g_premodelMatrix[2].setTranslate(45.0, 0.0, -85);


    //book
    g_premodelMatrix[3].setTranslate(31.0, 20.0, -85);

    g_premodelMatrix[4].setTranslate(51, -3.0, 87.0);
    g_premodelMatrix[4].rotate(180,0,1,0 );

    //door
    g_premodelMatrix[5].setTranslate(58.5, -3.0, 100.0);
    g_premodelMatrix[5].rotate(180,0,1,0 );
    g_premodelMatrix[5].scale(1, 1, 0.001);

   // g_premodelMatrix[5].setTranslate(0.0, 0.0, 100.0);
    g_premodelMatrix[6].setTranslate(0.0, 0.0, 100.0);
    g_premodelMatrix[7].setTranslate(39.0, 23.0, -85);
    g_premodelMatrix[7].scale(1, 1, 0.1);


    //覆盖door obj的其他部分
    g_premodelMatrix[8].setTranslate(57.5, 28.0, 99.0);

    // Camera表示人的位置，View表示视线方向
    var CameraX = 0.0;
    var CameraY = 10.0;
    var CameraZ = 85.0;
    var ViewX = 0.0;
    var ViewY = 0.0;
    var ViewZ = 0.0;

    var Angle = [0.0, 0.0];

    var viewProjMatrix = new Matrix4();
    var canvas;

    //整合
    var model;
    var gl;
    var currentAngle;

    //移动obj文件
    var Tx = new Float32Array(10);
    var Ty = new Float32Array(10);
    var Tz = new Float32Array(10);


    //其他人给予的提示信息
    var hintflag=0;

    var movecolset=0;

    var SOCKET_URL='http://192.168.1.109:3000';
    var socket = io.connect(SOCKET_URL);
    socket.on('connect',function(){
        console.log('connected');
    });


    socket.on("event",function(data){
        if(data=="mail"){
           console.log("可以打开门了");
            EnabelMoveCloset();
        }

    });

    //socket for update
 /*   var socket = io.connect('115.29.102.81:8090');
    socket.on('open',function(){
        console.log('connected');
        socket.send('success');
    });

    socket.send('success');
    socket.emit('my other event', { my: 'data' });
*/
    var jjjj = 0;
    //需要绑定this 这里面的this就是对于每一个模型来说总的内容的实例
    //这个函数实际上并没有优化的很好,现在只是相当于列出,但是这种方式比较方便
    function getDrawingInfo(ifTexture,objecctIndex) {


        // Create an arrays for vertex coordinates, normals, colors, and indices
        var numIndices = 0;
        for(var i = 0; i < this.objects.length; i++){
            numIndices += this.objects[i].numIndices;
            //每一个objects[i].numIndices 是它的所有的face的顶点数加起来
        }
        var numVertices = numIndices;
        var vertices = new Float32Array(numVertices * 3);
        var normals = new Float32Array(numVertices * 3);
        var colors = new Float32Array(numVertices * 4);
        var objectindex = new Float32Array(numVertices);

        //这个地方的16是不能转化成32的
        var indices = new Uint16Array(numIndices);

        //尝试增加贴图
        var textureVt = new Float32Array(numVertices * 3);

        // Set vertex, normal, texture and color
        //一个face一个face的遍历
        var index_indices = 0;
        for(i = 0; i < this.objects.length; i++){
            var object = this.objects[i];
            if(jjjj<1)console.log("object.faces.length",object.faces.length,this.objects.length);
            for(var j = 0; j < object.faces.length; j++){
                var face = object.faces[j];
                var color = findColor(this,face.materialName,objecctIndex);
                // console.log(face.materialName,color);
                var faceNormal = face.normal;
                for(var k = 0; k < face.vIndices.length; k++){
                    // Set index
                    indices[index_indices] = index_indices%MAX;

                    objectindex[index_indices]=objecctIndex;
                    // console.log(objectIndex);
                    // Copy vertex
                    var vIdx = face.vIndices[k];
                    var vertex = this.vertices[vIdx];
                    vertices[index_indices * 3    ] = vertex.x;
                    vertices[index_indices * 3 + 1] = vertex.y;
                    vertices[index_indices * 3 + 2] = vertex.z;

                    var tIdx = face.tIndices[k];
                    var Tvertex = this.textureVt[tIdx];
                    if(!!Tvertex) {
                        textureVt[index_indices * 3] = Tvertex.x;
                        textureVt[index_indices * 3 + 1] = Tvertex.y;
                        textureVt[index_indices * 3 + 2] = ifTexture;
                    }
                    else{
                        //有些是没有纹理坐标的,这个时候把纹理坐标置成系统默认值
                        textureVt[index_indices * 3] = 0;
                        textureVt[index_indices * 3 + 1] = 0;
                        textureVt[index_indices * 3 + 2] = ifTexture;
                    }

                    // Copy color
                    colors[index_indices * 4    ] = color.r;
                    colors[index_indices * 4 + 1] = color.g;
                    colors[index_indices * 4 + 2] = color.b;
                    colors[index_indices * 4 + 3] = color.a;
                    // console.log(colors,color);
                    // Copy normal
                    var nIdx = face.nIndices[k];
                    if(nIdx >= 0){
                        var normal = this.normals[nIdx];
                        normals[index_indices * 3    ] = normal.x;
                        normals[index_indices * 3 + 1] = normal.y;
                        normals[index_indices * 3 + 2] = normal.z;
                    }else{
                        normals[index_indices * 3    ] = faceNormal.x;
                        normals[index_indices * 3 + 1] = faceNormal.y;
                        normals[index_indices * 3 + 2] = faceNormal.z;
                    }
                    index_indices ++;
                }
                jjjj++;
            }
        }
        return new DrawingInfo(vertices, normals, colors, indices, textureVt,objectindex);                      //js 有这种写法的吗
    }

    var ready = true;

    //最多绘制65535个点，这里面的其他内容，都是和indices有倍数关系的，要改变indices的同时也要改变其他的
    function onReadComplete(gl, model, target,begin,numbers,ifTexture,index) {
        // Acquire the vertex coordinates and colors from OBJ file
        //console.log("target",target);
        if(index==5){
            var i=0;
        }
        var drawingInfo = getDrawingInfo.call(target,ifTexture,index);
        if(ready) {
            console.log(drawingInfo, "drawingInfo");
            ready = !ready;
        }
        // Write date into the buffer object
        gl.bindBuffer(gl.ARRAY_BUFFER, model.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.vertices.slice(begin*3,(begin+numbers)*3), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.normals.slice(begin*3,(begin+numbers)*3), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, model.colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.colors.slice(begin*4,(begin+numbers)*4), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, model.textBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.textureVt.slice(begin*3,(begin+numbers)*3), gl.STATIC_DRAW);


        //indicate which object it is for the picket
        gl.bindBuffer(gl.ARRAY_BUFFER, model.objectindexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.objectindex.slice(begin,(begin+numbers)), gl.STATIC_DRAW);


        // Write the indices to the buffer object
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, drawingInfo.indices.slice(begin,begin+numbers), gl.STATIC_DRAW);

        return drawingInfo;
    }

    function ShaderSourceFromScript(scriptID){
        var shaderScript = document.getElementById(scriptID);
        if (shaderScript == null) return "";

        var sourceCode = "";
        var child = shaderScript.firstChild;
        while (child)
        {
            if (child.nodeType == child.TEXT_NODE ) sourceCode += child.textContent;
            child = child.nextSibling;
        }

        return sourceCode;
    }


    var VSHADER_SOURCE = ShaderSourceFromScript("shader-vs");

    // Fragment shader program
    var FSHADER_SOURCE = ShaderSourceFromScript("shader-fs");



    var fog;
    function main() {

        // Color of Fog
       // var fogColor = new Float32Array([0.137, 0.231, 0.423]);
        var fogColor = new Float32Array([0.63, 0.69, 0.74]);
        // Distance of fog [where fog starts, where fog completely covers object]
        var fogDist = new Float32Array([1, 70]);
        // Position of eye point (world coordinates)

        // Retrieve <canvas> element
        canvas = document.getElementById('webgl');

        // Get the rendering context for WebGL
        gl = getWebGLContext(canvas);
        if (!gl) {
            console.log('Failed to get the rendering context for WebGL');
            return;
        }

        // Initialize shaders
        /* if (!((initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE))&&(initShaders(gl, VSHADER_SOURCE2, FSHADER_SOURCE2)))) {
         console.log('Failed to intialize shaders.');
         return;
         }*/


        // Initialize shaders
        if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
            console.log('Failed to intialize shaders.');
            return;
        }
        var  program=gl.program;

        // Set the clear color and enable the depth test
        gl.clearColor(0.2, 0.2, 0.2, 1.0);
        gl.enable(gl.DEPTH_TEST);	// 开启隐藏面消除

        // Get the storage locations of attribute and uniform variables

        program.a_Position = gl.getAttribLocation(program, 'a_Position');
        program.a_Normal = gl.getAttribLocation(program, 'a_Normal');
        program.a_Color = gl.getAttribLocation(program, 'a_Color');
        program.a_TextCord = gl.getAttribLocation(program, 'a_TextCord');
        program.objectindex = gl.getAttribLocation(program,'objectindex');
        program.u_MvpMatrix = gl.getUniformLocation(program, 'u_MvpMatrix');
        program.u_NormalMatrix = gl.getUniformLocation(program, 'u_NormalMatrix');
        program.u_ModelMatrix = gl.getUniformLocation(program, 'u_ModelMatrix');
        program.u_PickedObject = gl.getUniformLocation(program, 'u_PickedObject');
        program.u_Eye=gl.getUniformLocation(program, 'u_Eye');
        program.u_FogColor = gl.getUniformLocation(program, 'u_FogColor');
        program.u_FogDist = gl.getUniformLocation(program, 'u_FogDist');
        fog = gl.getUniformLocation(program,'fog');


        //fog
        gl.uniform3fv(program.u_FogColor, fogColor); // Colors
        gl.uniform2fv(program.u_FogDist, fogDist);   // Starting point and end point
        gl.uniform1i(fog,0);


        if (program.a_Position < 0 ||  program.a_Normal < 0 || program.a_Color < 0 || program.a_TextCord <0 ||
            !program.u_MvpMatrix || !program.u_NormalMatrix) {
            console.log('attribute, uniform失败');
            return;
        }

        // Prepare empty buffer objects for vertex coordinates, colors, and normals
        // 建立一堆空缓冲区等待obj文件的数据，具体建立步骤在initVertexBuffers函数内部，由自己实现
        model = initVertexBuffers(gl, program);
        if (!model) {
            console.log('Failed to set the vertex information');
            return;
        }

        // 投影行列計算
        // 设置视图矩阵与投影矩阵vp
        viewProjMatrix = new Matrix4();
        viewProjMatrix.setPerspective(45.0, canvas.width/canvas.height, 1.0, 5000.0);
        viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
        document.onkeydown = function(ev) {keydown(ev); };	// 注册键盘事件响应函数


        //initialize the txyz
        for(var i=0;i<10;i++){
            Tx[i]=0.0;
            Ty[i]=0.0;
            Tz[i]=0.0;
        }




        // Start reading the OBJ file
        //readOBJFile('../resources/ChairSwing.obj', modelObject,  mtlArray, objArray, 100, false, 0);
        // TextureArray存的是自定义的一些是否加载纹理的信息；modelObject存的是obj文件的信息

        //wall
        readOBJFile('./cube.obj', modelObject,  mtlArray, objArray, 10, false, 0);
        TextureArray[0]={ifTexture:0.0,TextureUrl:'./Monet.bmp',n:0};


        //文件箱
        readOBJFile('./052.obj', modelObject,  mtlArray, objArray, 0.5, false, 1);
        TextureArray[1]={ifTexture:1.0,TextureUrl:'./yellowcloset.bmp',n:1};


        //书的桌子
        readOBJFile('./052.obj', modelObject,  mtlArray, objArray, 0.5, false, 2);
        TextureArray[2]={ifTexture:1.0,TextureUrl:'./closet.bmp',n:2};


        //书籍
        readOBJFile('./045.obj', modelObject,  mtlArray, objArray, 0.5, false, 3);
        TextureArray[3]={ifTexture:1.0,TextureUrl:'./1.bmp',n:3};


        //文件箱-----后面是门
        readOBJFile('./051.obj', modelObject,  mtlArray, objArray, 0.5, false, 4);
        TextureArray[4]={ifTexture:1.0,TextureUrl:'./closet.bmp',n:4};

        //door
        readOBJFile('./door.obj', modelObject,  mtlArray, objArray, 0.1, false, 5);
        TextureArray[5]={ifTexture:0.0,TextureUrl:'./door.bmp',n:5};

        readOBJFile('./052.obj', modelObject,  mtlArray, objArray, 1000000, false, 6);
        TextureArray[6]={ifTexture:1.0,TextureUrl:'./1.bmp',n:6};

        //开关
        readOBJFile('./switch1.obj', modelObject,  mtlArray, objArray, 0.01, false, 7);
        TextureArray[7]={ifTexture:0.0,TextureUrl:'./1.bmp',n:7};

        //覆盖门的颜色
    //    readOBJFile('./cube.obj', modelObject,  mtlArray, objArray, 10, false, 8);
      //  TextureArray[8]={ifTexture:0.0,TextureUrl:'./1.bmp',n:8};



        Tz[3]=0;
        Tx[3]=10;


        //1.0代表加载纹理，0.0代表不加载纹理; n表示纹理编号

        currentAngle = [0.0, 0.0]; // Current rotation angle ([x-axis, y-axis] degrees)
        initEventHandlers(canvas);	// 鼠标控制物体旋转，切换视角
        //  gl.uniform1i(program.u_PickedObject, -1);                   //初始没有选中
        // 动画绘制
        var tick = function() {   // Start drawing
            var eye = new Float32Array([CameraX, CameraY, CameraZ, 1.0]);
            gl.uniform4fv(program.u_Eye, eye);

            // currentAngle = animate(currentAngle); // Update current rotation angle
            if(loadTextures.unload<=0){	// loadTextures是纹理锁，小于0表示没有待加载的纹理了，可以开始绘制了
                initDraw(gl);
                for(var ii=0;ii<modelObject.length;ii++){
                    draw(gl, gl.program, currentAngle, viewProjMatrix, model, ii, TextureArray);
                    // gl是该webgl的上下文，gl.program表示着色器链接，currentAngle表示当前物体的旋转角
                    // viewProjMatrix表示vp视角矩阵，model表示要绘制对象(缓冲区)的个数/长度；
                    // ii表示第ii个obj文件即即将绘制第ii个物体；TextureArray存的是一些纹理加载信息
                }
                // drawNoObj(gl,program2,currentAngle,viewProjMatrix);         //draw the things without the obj
            }
            requestAnimationFrame(tick, canvas);
        };


        for(var ii=0;ii<TextureArray.length;ii++){
            if(TextureArray[ii].ifTexture==1.0){
                loadTextures.unload++;
                initTextures(gl,TextureArray[ii]);
            }
        }
        initDraw(gl);	// 清除颜色与深度缓存
        tick();

    };

    function Seeproblem(){
        $('#myModal6').modal('hide');
        $('#myModal').modal();

    }

    function update(){
        var test = document.getElementById("answer1").value;
        if(test=="雾霾"){
            gl.uniform1i(fog,1);
            $('#myModal').modal('hide');
        }
        else{
            alert("答案错误");
        }
    }

    function moveBook(){
        g_premodelMatrix[3] = new Matrix4();
        g_premodelMatrix[3].setTranslate(39.0, 20.0, -85);

        $('#myModal1').modal('hide');
    }

    var x = document.getElementById("myAudio");
    var y = document.getElementById("openlight");
    //开灯
    function OpenSwitch(){
        $('#myModal4').modal();
        y.play();
        socket.emit('event', 'electricity'); //给其他房间开灯
    }

    //允许移动closet并且有开锁音响
    function EnabelMoveCloset(){
        $('#myModal5').modal();
        hintflag=1;
        x.play();
    }

    function keydown(ev) {
        viewProjMatrix = new Matrix4();
        viewProjMatrix.setPerspective(30.0, canvas.width/canvas.height, 1.0, 5000.0);
        // 计算当前运动方向
        var mylen = Math.sqrt((ViewZ - CameraZ)*(ViewZ - CameraZ)+(ViewX - CameraX)*(ViewX - CameraX));
        var mysin = (ViewZ - CameraZ)/mylen;
        var mycos = (ViewX - CameraX)/mylen;

        // 根据键盘控制与当前运动方向可以计算走一步之后的位置与视点
        if (ev.keyCode == 39) {			// The right arrow key was pressed
            if(movecolset==1){
                g_premodelMatrix[4] = new Matrix4();
                g_premodelMatrix[4].setTranslate(28.5, -3.0, 87.0);
                g_premodelMatrix[4].rotate(180,0,1,0 );
                viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
            }
            else {
                CameraZ += 5 * mycos;
                CameraX -= 5 * mysin;
                if (CameraZ >= -105 && CameraZ <= 105 && CameraX >= -45 && CameraX <= 45) {
                    ViewX = -Math.sin(Angle[1] / 180.0 * 3.1415926) * 100.0 + CameraX;
                    if (Angle[1] > -90 && Angle[1] < 90)
                        ViewZ = -Math.sqrt(10000.0 - (ViewX - CameraX) * (ViewX - CameraX)) + CameraZ;
                    else ViewZ = Math.sqrt(10000.0 - (ViewX - CameraX) * (ViewX - CameraX)) + CameraZ;
                }
                else {
                    CameraZ -= 5 * mycos;
                    CameraX += 5 * mysin;
                }
                viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
            }
        } else if (ev.keyCode == 37) { 	// The left arrow key was pressed


                CameraZ -= 5 * mycos;
                CameraX += 5 * mysin;
                if (CameraZ >= -105 && CameraZ <= 105 && CameraX >= -45 && CameraX <= 45) {
                    ViewX = -Math.sin(Angle[1] / 180.0 * 3.1415926) * 100.0 + CameraX;
                    if (Angle[1] > -90 && Angle[1] < 90)
                        ViewZ = -Math.sqrt(10000.0 - (ViewX - CameraX) * (ViewX - CameraX)) + CameraZ;
                    else ViewZ = Math.sqrt(10000.0 - (ViewX - CameraX) * (ViewX - CameraX)) + CameraZ;
                }
                else {
                    CameraZ += 5 * mycos;
                    CameraX -= 5 * mysin;
                }
                viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);

        }else if (ev.keyCode == 40) { 	// The back arrow key was pressed
            CameraZ -= 5 * mysin;
            CameraX -= 5 * mycos;
            if (CameraZ>=-105 && CameraZ<=105 && CameraX>=-45 && CameraX<=45) {
                ViewX = -Math.sin(Angle[1]/180.0*3.1415926)*100.0+CameraX;
                if (Angle[1]>-90 && Angle[1] < 90)
                    ViewZ = -Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;
                else ViewZ = Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;
            }
            else {
                CameraZ += 5 * mysin;
                CameraX += 5 * mycos;
            }
            viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
        }
        else if (ev.keyCode == 38) { 	// The front arrow key was pressed
            CameraZ += 5 * mysin;
            CameraX += 5 * mycos;
            if (CameraZ>=-105 && CameraZ<=105 && CameraX>=-45 && CameraX<=45) {
                ViewX = -Math.sin(Angle[1]/180.0*3.1415926)*100.0+CameraX;
                if (Angle[1]>-90 && Angle[1] < 90)
                    ViewZ = -Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;
                else ViewZ = Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;
            }
            else {
                CameraZ -= 5 * mysin;
                CameraX -= 5 * mycos;
            }
            viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
        }
        else if(ev.keyCode==87){
            Tz[3]+=10;
            viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
        }

        else {
            viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
            return;
        }
    }

    // 鼠标控制旋转
    function initEventHandlers(canvas) {
        var dragging = false;         // Dragging or not
        var lastX = -1, lastY = -1;   // Last position of the mouse

        canvas.onmousedown =  function (ev) {   // Mouse is pressed             //为什么内部的参数不需要传进去
            var flag =true;
            var x = ev.clientX, y = ev.clientY;
            var rect = ev.target.getBoundingClientRect();
            if (rect.left <= x && x < rect.right && rect.top <= y && y < rect.bottom) {
                // If Clicked position is inside the <canvas>, update the selected surface
                var x_in_canvas = x - rect.left, y_in_canvas = rect.bottom - y;
                var face = checkObject( x_in_canvas, y_in_canvas, currentAngle, viewProjMatrix,  model);

                if(face==1){
                    $('#myModal6').modal();
                    flag=false;
                }
                else if(face==3){
                    $('#myModal1').modal();
                    flag=false;
                }
                //移动门
                else if(face==4){

                    if(hintflag==0) {
                        $('#myModal2').modal();
                    }
                    else{
                        $('#myModal3').modal();
                        movecolset=1;
                    }
                    flag=false;
                }
                else if(face==7){
                    OpenSwitch();
                    falg=false;
                }
                else if(face==5){
                    GameOver();
                    flag=flase;
                }

                //    TextureArray[1]={ifTexture:1.0,TextureUrl:'./1.bmp',n:0};
                //  readOBJFile('./001.obj', modelObject,  mtlArray, objArray, 2, false, 0);
                // }

                //  alert(face +"objece is choosed");
                gl.uniform1i(gl.program.u_PickedObject, -1);
                Draw(gl,  currentAngle, viewProjMatrix, model,  TextureArray);
                //draw(gl, n, currentAngle, viewProjMatrix, u_MvpMatrix);
                if(flag) {
                    dragging = true;
                }
            }
        }

        canvas.onmouseup = function(ev) { dragging = false;  }; // Mouse is released

        canvas.onmousemove = function(ev) { // Mouse is moved
            var x = ev.clientX, y = ev.clientY;
            if (dragging) {
                viewProjMatrix = new Matrix4();
                viewProjMatrix.setPerspective(30.0, canvas.width/canvas.height, 1.0, 5000.0);
                var factor = 100/canvas.height; // 使dx和dy与<canvas>自身大小无关
                var dx = factor * (x - lastX);
                var dy = factor * (y - lastY);
                // 视点在以观察者位置为圆心，100为半径的球上移动
                Angle[0] = Math.max(Math.min(Angle[0] + dy, 90.0), -90.0);
                Angle[1] = Angle[1] + dx;
                if (Angle[1]>180.0)
                    Angle[1] -= 360.0;
                if (Angle[1]<-180.0)
                    Angle[1] += 360.0;
                // ViewY += dy;
                // ViewX -= dx;
                ViewX = -Math.sin(Angle[1]/180.0*3.1415926)*100.0+CameraX;
                ViewY = Math.sin(Angle[0]/180.0*3.1415926)*100.0;
                if (Angle[1]>-90 && Angle[1] < 90)
                    ViewZ = -Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;
                else ViewZ = Math.sqrt(10000.0-(ViewX-CameraX)*(ViewX-CameraX))+CameraZ;
                // Limit x-axis rotation angle to -90 to 90 degrees
                // currentAngle[0] = Math.max(Math.min(currentAngle[0] + dy, 90.0), -90.0);
                // currentAngle[1] = currentAngle[1] + dx;
                viewProjMatrix.lookAt(CameraX, CameraY, CameraZ, ViewX, ViewY, ViewZ, 0.0, 1.0, 0.0);
            }
            lastX = x, lastY = y;
        };
    }



    // Create an buffer object and perform an initial configuration
    // 创建多个空缓冲区并初始化，使得每个attribute都能有自己的缓冲区传数据到着色器
    function initVertexBuffers(gl, program) {
        var o = new Object(); // Utilize Object object to return multiple buffer objects
        o.vertexBuffer = createEmptyArrayBuffer(gl, program.a_Position, 3, gl.FLOAT);
        o.normalBuffer = createEmptyArrayBuffer(gl, program.a_Normal, 3, gl.FLOAT);
        o.colorBuffer = createEmptyArrayBuffer(gl, program.a_Color, 4, gl.FLOAT);
        o.textBuffer = createEmptyArrayBuffer(gl, program.a_TextCord, 3, gl.FLOAT);
        o.objectindexBuffer = createEmptyArrayBuffer(gl, program.objectindex, 1, gl.FLOAT);
        o.indexBuffer = gl.createBuffer();

        if (!o.vertexBuffer || !o.normalBuffer || !o.textBuffer || !o.colorBuffer || !o.indexBuffer) { return null; }

        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        return o;
    }

    // Create a buffer object, assign it to attribute variables, and enable the assignment
    // 具体创建缓冲区过程，其中a_attribute在main函数开头已设好着色器地址
    function createEmptyArrayBuffer(gl, a_attribute, num, type) {
        var buffer =  gl.createBuffer();  // Create a buffer object
        if (!buffer) {
            console.log('Failed to create the buffer object');
            return null;
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(a_attribute, num, type, true, 0, 0);  // Assign the buffer object to the attribute variable
        gl.enableVertexAttribArray(a_attribute);  // Enable the assignment

        return buffer;
    }

    //这里面的n应该是标号，只不过暂时没有用到
    function initTextures(gl,thisTexture) {
        console.log(gl,"image to onload ..",gl);
        var texture = gl.createTexture();   // Create a texture object
        if (!texture) {
            console.log('Failed to create the texture object');
            return false;
        }

        // Get the storage location of u_Sampler
        var u_Sampler = gl.getUniformLocation(gl.program, 'u_Sampler');
        //console.log("u_Sampler",u_Sampler);
        if (!u_Sampler) {
            console.log('Failed to get the storage location of u_Sampler');
            return false;
        }
        var image = new Image();  // Create the image object
        if (!image) {
            console.log('Failed to create the image object');
            return false;
        }
        // Register the event handler to be called on loading an image
        image.onload = function(){
            console.log("image onload");
            loadTexture(gl, thisTexture.n, texture, u_Sampler, image);
        };
        // Tell the browser to load an image
        image.src = thisTexture.TextureUrl;

        return true;
    }

    function loadTexture(gl, n, texture, u_Sampler, image) {
        var TextureList = [gl.TEXTURE0,gl.TEXTURE1,gl.TEXTURE2,gl.TEXTURE3,gl.TEXTURE4,gl.TEXTURE5,gl.TEXTURE6,gl.TEXTURE7];

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // Flip the image's y axis
        // Enable texture unit0
        gl.activeTexture(TextureList[n]);
        // Bind the texture object to the target
        gl.bindTexture(gl.TEXTURE_2D, texture);

        // Set the texture parameters
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        // Set the texture image
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);

        loadTextures.unload-=1;
        // Set the texture unit 0 to the sampler
        // gl.uniform1i(u_Sampler, n);
    }


    var tttt = 0;

    // 开始绘制前，清除颜色与深度缓存
    function initDraw(gl){
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);  // Clear color and depth buffers
    }

    // 描画関数
    // gl是该webgl的上下文，program表示着色器链接，angle表示当前物体的旋转角
    // viewProjMatrix表示vp视角矩阵，model表示要绘制对象(缓冲区)的个数/长度(一个物体的参数数量)；
    // index表示第ii个obj文件；TextureArray存的是一些纹理信息
    function draw(gl, program, angle, viewProjMatrix, model, index, TextureArray) {

      /*  if(!mtlArray[index] || !objArray[index]){
            console.log("no object!!!");
            return;
        }
*/

        if( !objArray[index]){
            console.log("no object!!!");
            return;
        }


        if(TextureArray[index].ifTexture==1.0){		// 如果等于1，说明要加载纹理
            var u_Sampler = gl.getUniformLocation(gl.program, 'u_Sampler');
            gl.uniform1i(u_Sampler, TextureArray[index].n);
        }

        var numIndices = 0;
        for(var i = 0; i < modelObject[index].objects.length; i++){
            numIndices += modelObject[index].objects[i].numIndices;
            //每一个objects[i].numIndices 是它的所有的face的顶点数加起来
        }



        for(var ii=0;ii<Math.ceil(numIndices/MAX);ii++){
            if(tttt<1)console.log("when tttt < 1",numIndices,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX);
            g_drawingInfo = onReadComplete(gl, model, modelObject[index],ii*MAX,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX,TextureArray[index].ifTexture,index);
            g_objDoc = null;
            g_modelMatrix.setRotate(angle[0], 1.0, 0.0, 0.0); // 设置模型旋转矩阵
            g_modelMatrix.rotate(angle[1], 0.0, 1.0, 0.0);
            g_modelMatrix.translate(Tx[index],Ty[index],Tz[index]);

            if(index==1){
                g_modelMatrix.translate(10.0,0.0,0.0);

            }


            g_mvpMatrix.set(viewProjMatrix);

            // Calculate the normal transformation matrix and pass it to u_NormalMatrix
            g_normalMatrix.setInverseOf(g_modelMatrix);
            g_normalMatrix.transpose();
            gl.uniformMatrix4fv(program.u_NormalMatrix, false, g_normalMatrix.elements);
            gl.uniformMatrix4fv(program.u_ModelMatrix, false, g_modelMatrix.elements);

            // Calculate the model view project matrix and pass it to u_MvpMatrix
            // g_mvpMatrix.multiply(g_modelMatrix);
            //g_mvpMatrix.setOrtho(-100,100,-100,100,-50,50);
            g_mvpMatrix.multiply(g_modelMatrix);


            g_mvpMatrix.multiply(g_premodelMatrix[index]);
            /*if (index == 1) {
             g_mvpMatrix.multiply(aa);
             }
             else if (index == 2) {
             g_mvpMatrix.multiply(bb);
             }*/

            if (index == 0) {	// 墙
                g_MvpMatrix.set(g_mvpMatrix);	// 不能直接等于
                g_ModelMatrix.setTranslate(0.0, 0.0, -110.0);
                g_ModelMatrix.scale(15.0, 10.0, 0.1);	// 先让物体在原点缩放再进行平移，不然缩放会影响坐标位置；且后方较远，x方向放大得多一点
                g_MvpMatrix.multiply(g_ModelMatrix);
                gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
                gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);

                g_MvpMatrix.set(g_mvpMatrix);	// 后墙
                g_ModelMatrix.setTranslate(0.0, 0.0, 110.0);
                g_ModelMatrix.scale(15.0, 10.0, 0.1);
                g_MvpMatrix.multiply(g_ModelMatrix);
                gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
                gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);

                g_MvpMatrix.set(g_mvpMatrix);	// 下墙
                g_ModelMatrix.setTranslate(0.0, -10.0, 0.0);
                g_ModelMatrix.scale(20.0, 0.1, 10.0);
                g_MvpMatrix.multiply(g_ModelMatrix);
                //g_mvpMatrix.scale(1.0, 1.0, 10.0);
                gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
                gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);

                g_MvpMatrix.set(g_mvpMatrix);	// 上墙
                g_ModelMatrix.setTranslate(0.0, 30.0, 0.0);
                g_ModelMatrix.scale(10.0, 0.1, 10.0);
                g_MvpMatrix.multiply(g_ModelMatrix);
                //g_mvpMatrix.scale(1.0, 1.0, 10.0);
                gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
                gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);

                g_MvpMatrix.set(g_mvpMatrix);	// 左墙
                g_ModelMatrix.setTranslate(-65.0, 0.0, 0.0);
                g_ModelMatrix.scale(0.2, 6.0, 22.0);
                g_MvpMatrix.multiply(g_ModelMatrix);
                //g_mvpMatrix.scale(1.0, 1.0, 10.0);
                gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
                gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);

                g_MvpMatrix.set(g_mvpMatrix);	// 右墙
                g_ModelMatrix.setTranslate(65.0, 0.0, 0.0);
                g_ModelMatrix.scale(0.1, 6.0, 22.0);
                g_MvpMatrix.multiply(g_ModelMatrix);
                //g_mvpMatrix.scale(1.0, 1.0, 10.0);
                gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
                gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);


                g_MvpMatrix.set(g_mvpMatrix);	// 后墙
                g_ModelMatrix.setTranslate(0.0, 0.0, 110.0);
                g_ModelMatrix.scale(20.0, 10.0, 0.1);
                g_MvpMatrix.multiply(g_ModelMatrix);
                gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
                gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);


                g_MvpMatrix.set(g_mvpMatrix);	// 后墙
                g_ModelMatrix.setTranslate(57.5, 23.8, 95.0);
                g_ModelMatrix.scale(13.0, 1.5, 0.001);
                g_MvpMatrix.multiply(g_ModelMatrix);
                gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
                gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);


                g_MvpMatrix.set(g_mvpMatrix);	// 后墙
                g_ModelMatrix.setTranslate(-79.5, 5.8, 93.0);
                g_ModelMatrix.scale(13.0, 3.0, 0.001);
                g_MvpMatrix.multiply(g_ModelMatrix);
                gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
                gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);


                /*                g_MvpMatrix.set(g_mvpMatrix);	// 不能直接等于
                                g_ModelMatrix.setTranslate(-163, 0.0, -20.0);
                                g_ModelMatrix.scale(10.0, 10.0, 0.1);	// 先让物体在原点缩放再进行平移，不然缩放会影响坐标位置；且后方较远，x方向放大得多一点
                                g_MvpMatrix.multiply(g_ModelMatrix);
                                gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_MvpMatrix.elements);
                                gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
                */



            }
//            g_mvpMatrix.rotate(angle[0], 1.0, 0.0, 0.0);
//            g_mvpMatrix.rotate(angle[1], 0.0, 1.0, 0.0);
            //g_mvpMatrix.translate(-200.0,0.0,0.0);

            else {	// 一般物体

                g_mvpMatrix.translate(0.0, -9.0, 0.0);
                gl.uniformMatrix4fv(program.u_MvpMatrix, false, g_mvpMatrix.elements);

                // Draw
                gl.drawElements(gl.TRIANGLES,(numIndices-ii*MAX)<MAX?(numIndices-ii*MAX):MAX, gl.UNSIGNED_SHORT, 0);
            }
        }

        tttt++;

    }

    function drawNoObj(gl,program,angle, viewProjMatrix){
        gl.useProgram(program);

        var n = initVertexBuffers(gl,program);
        if (n < 0) {
            console.log('Failed to set the vertex information');
            return;
        }

        // Specify the color for clearing <canvas>
        gl.clearColor(0.0, 0.0, 0.0, 1.0);

        // Set texture
        if (!initTextures(gl, n,program)) {
            console.log('Failed to intialize the texture.');
            return;
        }



    }

function GameOver(){
     $('#myModal7').modal();
     socket.emit('event', 'over2');
     window.location=SOCKET_URL;
}

    function Draw(gl,  currentAngle, viewProjMatrix, model,  TextureArray){
        if(loadTextures.unload<=0){
            initDraw(gl);
            for(var ii=0;ii<modelObject.length;ii++){
                draw(gl, gl.program, currentAngle, viewProjMatrix, model,ii,TextureArray);
            }
        }
    }


    function checkObject( x, y, currentAngle,  viewProjMatrix,  model) {
        var pixels = new Uint8Array(4); // Array for storing the pixel value
        gl.uniform1i(gl.program.u_PickedObject, 1);      // Draw by writing surface number into alpha value
        Draw(gl,  currentAngle, viewProjMatrix, model,  TextureArray);                                  //重新画一遍，将objectindex写到rgba 中的a
        // Read the pixel value of the clicked position. pixels[3] is the surface number
        gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

        return pixels[3];
    }



</script>
</body>
</html>